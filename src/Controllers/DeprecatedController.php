<?php

namespace FinicityAPILib\Controllers;

use FinicityAPILib\APIException;
use FinicityAPILib\APIHelper;
use FinicityAPILib\Configuration;
use FinicityAPILib\Models;
use FinicityAPILib\Exceptions;
use FinicityAPILib\Http\HttpRequest;
use FinicityAPILib\Http\HttpResponse;
use FinicityAPILib\Http\HttpMethod;
use FinicityAPILib\Http\HttpContext;
use FinicityAPILib\Servers;
use Unirest\Request;

/**
 * @todo Add a general description for this controller.
 */
class DeprecatedController extends BaseController
{
    /**
     * @var DeprecatedController The reference to *Singleton* instance of this class
     */
    private static $instance;

    /**
     * Returns the *Singleton* instance of this class.
     * @return DeprecatedController The *Singleton* instance.
     */
    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }
        
        return static::$instance;
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param integer $customerId   Finicity’s ID of the customer
     * @param string  $reportId     Finicity’s ID of the report
     * @param string  $accept       Replace 'json' with 'xml' if preferred
     * @param string  $contentType  Replace 'json' with 'xml' if preferred
     * @param string  $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string  $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                              retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReportByCustomer(
        $customerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($customerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/customers/{customerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'customerId'   => $customerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\AuditableReport');
    }

    /**
     * No matter how you plan on implementing Finicity Connect, you’ll need to generate and retrieve a
     * Finicity Connect Link.  You will need to specify what type of Finicity Connect you need depending on
     * what will happen once the customer accounts and transaction data are gathered.  Below you’ll find
     * how to generate the Connect link as well as where to specify what type of Finicity Connect you need.
     *
     * Once you have generated the link it will only last until the authentication token under which it was
     * generated expires.  After that you will need to regenerate the Connect link under a new
     * authentication token. We recommend generating a new authentication token when you generate a Connect
     * link, to guarantee a full two hour life-span.
     *
     * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
     * The Connect type is controlled by the “type” code in the call.  Many times the type also
     * corresponds to the report that will be run upon completing the Connect flow.
     *
     * It is best to use the documentation for the specific use case you are interested in as the
     * documentation here is a list of all the possible parameters you can send for this endpoint depending
     * on the use case. See the following more specific documentation for your use case.......
     * Generate Finicity Connect URL (Data and Payments)
     * Generate Finicity Connect URL (Lending)
     * Generate Finicity Connect URL (Lite)
     * Generate Finicity Connect URL (Fix)
     *
     * @param string                           $accept application/json, application/xml
     * @param Models\GenerateConnectURLRequest $body   Expected body to be sent with the request
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function generateConnectURLAllTypes(
        $accept,
        $body
    ) {
        //check that all required arguments are provided
        if (!isset($accept, $body)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/connect/v1/generate';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'content-type'  => 'application/json; charset=utf-8',
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept
        );

        //json encode body
        $_bodyJson = Request\Body::Json($body);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\GenerateConnectURLResponse');
    }

    /**
     * This service has been replaced by version 2 call now "Migrate Institution Login Accounts"
     *
     * This service is to migrate accounts from legacy FI to new OAuth FI.
     *
     * A successful API response will return a list of accounts for the given institution login id with an
     * http status code as 200.
     *
     * @param integer $customerId         Finicity’s ID of the customer for the institutionLoginId of accounts
     * @param integer $institutionLoginId Finicity's institutionLoginId for the set of accounts to be migrated
     * @param integer $newInstitutionId   New OAuth FI ID where accounts  will be migrated
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function migrateInstitutionLoginAccountsV1(
        $customerId,
        $institutionLoginId,
        $newInstitutionId
    ) {
        //check that all required arguments are provided
        if (!isset($customerId, $institutionLoginId, $newInstitutionId)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = 
            '/aggregation/v1/customers/{customerId}/institutionLogins/{institutionLoginId}/institutions/{newInstitutionId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'customerId'         => $customerId,
            'institutionLoginId' => $institutionLoginId,
            'newInstitutionId'   => $newInstitutionId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => BaseController::USER_AGENT,
            'Accept'           => 'application/json',
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\CustomerAccounts');
    }

    /**
     * Enroll a testing customer. A testing customer may only register accounts with FinBank institutions.
     *
     * @param string                    $contentType  application/json, application/xml
     * @param string                    $accept       application/json, application/xml
     * @param Models\AddCustomerRequest $body         The Fields For The New Testing Customer
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function addTestingCustomerV1(
        $contentType,
        $accept,
        $body
    ) {
        //check that all required arguments are provided
        if (!isset($contentType, $accept, $body)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/aggregation/v1/customers/testing';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Content-Type'    => $contentType,
            'Accept'          => $accept
        );

        //json encode body
        $_bodyJson = Request\Body::Json($body);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\AddCustomerResponse');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param string $consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
     * @param string $reportId     Finicity’s ID of the report (UUID with max length 32 characters)
     * @param string $accept       Replace 'json' with 'xml' if preferred
     * @param string $contentType  Replace 'json' with 'xml' if preferred
     * @param string $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                             retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReportByConsumer(
        $consumerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($consumerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/consumers/{consumerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'consumerId'   => $consumerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\AuditableReport');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param string $consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
     * @param string $reportId     Finicity’s ID of the report
     * @param string $accept       Replace 'json' with 'xml' if preferred
     * @param string $contentType  Replace 'json' with 'xml' if preferred
     * @param string $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                             retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVOAReportByConsumer(
        $consumerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($consumerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/consumers/{consumerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'consumerId'   => $consumerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\VOAReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param integer $customerId   Finicity’s ID of the customer
     * @param string  $reportId     Finicity’s ID of the report
     * @param string  $accept       Replace 'json' with 'xml' if preferred
     * @param string  $contentType  Replace 'json' with 'xml' if preferred
     * @param string  $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string  $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                              retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVOIE_txverify_ReportByCustomer(
        $customerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($customerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/customers/{customerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'customerId'   => $customerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\VOIEPaystubWithTxverifyReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param string $consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
     * @param string $reportId     Finicity’s ID of the report
     * @param string $accept       Replace 'json' with 'xml' if preferred
     * @param string $contentType  Replace 'json' with 'xml' if preferred
     * @param string $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                             retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVOIReportByConsumer(
        $consumerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($consumerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/consumers/{consumerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'consumerId'   => $consumerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\VOIReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param integer $customerId   Finicity’s ID of the customer
     * @param string  $reportId     Finicity’s ID of the report (UUID with max length 32 characters)
     * @param string  $accept       Replace 'json' with 'xml' if preferred
     * @param string  $contentType  Replace 'json' with 'xml' if preferred
     * @param string  $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string  $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                              retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVOIReportByCustomer(
        $customerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($customerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/customers/{customerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'customerId'   => $customerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\VOIReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param string $consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
     * @param string $reportId     Finicity’s ID of the report
     * @param string $accept       Replace 'json' with 'xml' if preferred
     * @param string $contentType  Replace 'json' with 'xml' if preferred
     * @param string $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                             retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVOAWithIncomeReportByConsumer(
        $consumerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($consumerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/consumers/{consumerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'consumerId'   => $consumerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\VOAWithIncomeReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param integer $customerId   Finicity’s ID of the customer
     * @param string  $reportId     Finicity’s ID of the report
     * @param string  $accept       Replace 'json' with 'xml' if preferred
     * @param string  $contentType  Replace 'json' with 'xml' if preferred
     * @param string  $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string  $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                              retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVOAWithIncomeReportByCustomer(
        $customerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($customerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/customers/{customerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'customerId'   => $customerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\VOAWithIncomeReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param integer $customerId   Finicity’s ID of the customer
     * @param string  $reportId     Finicity’s ID of the report
     * @param string  $accept       Replace 'json' with 'xml' if preferred
     * @param string  $contentType  Replace 'json' with 'xml' if preferred
     * @param string  $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string  $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                              retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getPrequalificationVOAReportByCustomer(
        $customerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($customerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/customers/{customerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'customerId'   => $customerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\PrequalificationReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param string $consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
     * @param string $reportId     Finicity’s ID of the report
     * @param string $accept       Replace 'json' with 'xml' if preferred
     * @param string $contentType  Replace 'json' with 'xml' if preferred
     * @param string $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                             retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getPrequalificationReportByConsumer(
        $consumerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($consumerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/consumers/{consumerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'consumerId'   => $consumerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\PrequalificationReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param string $consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
     * @param string $reportId     Finicity’s ID of the report
     * @param string $accept       Replace 'json' with 'xml' if preferred
     * @param string $contentType  Replace 'json' with 'xml' if preferred
     * @param string $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                             retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getPayStatementByConsumer(
        $consumerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($consumerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/consumers/{consumerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'consumerId'   => $consumerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\PayStatementReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param integer $customerId   Finicity’s ID of the customer
     * @param string  $reportId     Finicity’s ID of the report
     * @param string  $accept       Replace 'json' with 'xml' if preferred
     * @param string  $contentType  Replace 'json' with 'xml' if preferred
     * @param string  $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string  $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                              retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVOAReportByCustomer(
        $customerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($customerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/customers/{customerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'customerId'   => $customerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\VOAReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param string $consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
     * @param string $reportId     Finicity’s ID of the report
     * @param string $accept       Replace 'json' with 'xml' if preferred
     * @param string $contentType  Replace 'json' with 'xml' if preferred
     * @param string $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                             retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVOIE_txverify_ReportByConsumer(
        $consumerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($consumerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/consumers/{consumerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'consumerId'   => $consumerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\VOIEPaystubWithTxverifyReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param integer $customerId   Finicity’s ID of the customer
     * @param string  $reportId     Finicity’s ID of the report
     * @param string  $accept       Replace 'json' with 'xml' if preferred
     * @param string  $contentType  Replace 'json' with 'xml' if preferred
     * @param string  $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string  $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                              retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getPayStatementExtractionByCustomer(
        $customerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($customerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/customers/{customerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'customerId'   => $customerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\PayStatementReportRecord');
    }

    /**
     * This version 1 service has been replaced with version 2
     *
     * Enroll an active customer, which is the actual owner of one or more real-world accounts. This is a
     * billable customer.
     *
     * This service is not available from the Test Drive. Calls to this service before enrolling in a paid
     * plan will return HTTP 429 (Too Many Requests).
     *
     * @param string                    $accept       application/json, application/xml
     * @param string                    $contentType  application/json, application/xml
     * @param Models\AddCustomerRequest $body         The Fields For The New Customer
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function addCustomerV1(
        $accept,
        $contentType,
        $body
    ) {
        //check that all required arguments are provided
        if (!isset($accept, $contentType, $body)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/aggregation/v1/customers/active';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //json encode body
        $_bodyJson = Request\Body::Json($body);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\AddCustomerResponse');
    }

    /**
     * No matter how you plan on implementing Finicity Connect, you’ll need to generate and retrieve a
     * Finicity Connect Link.  You will need to specify what type of Finicity Connect you need depending on
     * what will happen once the customer accounts and transaction data are gathered.  Below you’ll find
     * how to generate the Connect link as well as where to specify what type of Finicity Connect you need.
     *
     * Once you have generated the link it will only last until the authentication token under which it was
     * generated expires.  After that you will need to regenerate the Connect link under a new
     * authentication token. We recommend generating a new authentication token when you generate a Connect
     * link, to guarantee a full two hour life-span.
     *
     * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
     * The Connect type is controlled by the “type” code in the call.
     *
     * See the specific documentation for the types to see more details on the flow. This documentation
     * gives the applicable implementation details for the following types......
     *
     * - ach
     * - aggregation
     *
     * @param string                                          $accept application/json, application/xml
     * @param Models\GenerateConnectURLRequestDataAndPayments $body   Expected body to be sent with the request
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function generateConnectURLDataAndPaymentsConnect(
        $accept,
        $body
    ) {
        //check that all required arguments are provided
        if (!isset($accept, $body)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/connect/v1/generate';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'content-type'  => 'application/json; charset=utf-8',
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept
        );

        //json encode body
        $_bodyJson = Request\Body::Json($body);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\GenerateConnectURLResponse');
    }

    /**
     * No matter how you plan on implementing Finicity Connect, you’ll need to generate and retrieve a
     * Finicity Connect Link.  You will need to specify what type of Finicity Connect you need depending on
     * what will happen once the customer accounts and transaction data are gathered.  Below you’ll find
     * how to generate the Connect link as well as where to specify what type of Finicity Connect you need.
     *
     * Once you have generated the link it will only last until the authentication token under which it was
     * generated expires.  After that you will need to regenerate the Connect link under a new
     * authentication token. We recommend generating a new authentication token when you generate a Connect
     * link, to guarantee a full two hour life-span.
     *
     * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
     * The Connect type is controlled by the “type” code in the call. For lending, each type signifies a
     * report that will be generated as part of the connect flow unless otherwise specified.
     *
     * See the specific documentation for the types to see more details on the flow. This documentation
     * gives the applicable implementation details for the following types......
     *
     * - voa
     * - voahistory
     * - voi
     * - voieTxVerify
     * - voieStatement
     * - payStatement
     * - assetSummary
     * - preQualVoa
     *
     * @param string                                  $accept application/json, application/xml
     * @param Models\GenerateConnectURLRequestLending $body   Expected body to be sent with the request
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function generateConnectURLLending(
        $accept,
        $body
    ) {
        //check that all required arguments are provided
        if (!isset($accept, $body)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/connect/v1/generate';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'content-type'  => 'application/json; charset=utf-8',
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept
        );

        //json encode body
        $_bodyJson = Request\Body::Json($body);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\GenerateConnectURLResponse');
    }

    /**
     * No matter how you plan on implementing Finicity Connect, you’ll need to generate and retrieve a
     * Finicity Connect Link.  You will need to specify what type of Finicity Connect you need depending on
     * what will happen once the customer accounts and transaction data are gathered.  Below you’ll find
     * how to generate the Connect link as well as where to specify what type of Finicity Connect you need.
     *
     * Once you have generated the link it will only last until the authentication token under which it was
     * generated expires.  After that you will need to regenerate the Connect link under a new
     * authentication token. We recommend generating a new authentication token when you generate a Connect
     * link, to guarantee a full two hour life-span.
     *
     * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
     * The Connect type is controlled by the “type” code in the call.
     *
     * See the specific documentation for the types to see more details on the flow. This documentation
     * gives the applicable implementation details for the following types......
     *
     * - lite
     *
     * @param string                               $accept application/json, application/xml
     * @param Models\GenerateConnectURLRequestLite $body   Expected body to be sent with the request
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function generateConnectURLLite(
        $accept,
        $body
    ) {
        //check that all required arguments are provided
        if (!isset($accept, $body)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/connect/v1/generate';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'content-type'  => 'application/json; charset=utf-8',
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept
        );

        //json encode body
        $_bodyJson = Request\Body::Json($body);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\GenerateConnectURLResponse');
    }

    /**
     * No matter how you plan on implementing Finicity Connect, you’ll need to generate and retrieve a
     * Finicity Connect Link.  You will need to specify what type of Finicity Connect you need depending on
     * what will happen once the customer accounts and transaction data are gathered.  Below you’ll find
     * how to generate the Connect link as well as where to specify what type of Finicity Connect you need.
     *
     * Once you have generated the link it will only last until the authentication token under which it was
     * generated expires.  After that you will need to regenerate the Connect link under a new
     * authentication token. We recommend generating a new authentication token when you generate a Connect
     * link, to guarantee a full two hour life-span.
     *
     * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
     * The Connect type is controlled by the “type” code in the call.
     *
     * See the specific documentation for the types to see more details on the flow. This documentation
     * gives the applicable implementation details for the following types......
     *
     * - fix
     *
     * @param string                              $accept application/json, application/xml
     * @param Models\GenerateConnectURLRequestFix $body   Expected body to be sent with the request
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function generateConnectURLFix(
        $accept,
        $body
    ) {
        //check that all required arguments are provided
        if (!isset($accept, $body)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/connect/v1/generate';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'content-type'  => 'application/json; charset=utf-8',
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept
        );

        //json encode body
        $_bodyJson = Request\Body::Json($body);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\GenerateConnectURLResponse');
    }

    /**
     * A connect email sends an email to the customer which will contain a link to the connect flow. You
     * will need to specify what type of Finicity Connect you need depending on what will happen once the
     * customer accounts and transaction data are gathered.
     *
     * Several Finicity products utilize Finicity Connect, and most products have their own type of Connect.
     * The Connect type is controlled by the “type” code in the call.  Many times the type also
     * corresponds to the report that will be run upon completing the Connect flow.
     *
     * For Send Connect Email service it does not support the types aggregation, lite and fix.
     *
     * See the endpoint Generate Finicity Connect URL (Lending) for additional details on a non email
     * implementation.
     *
     * @param string                             $accept application/json
     * @param Models\GenerateConnectEmailRequest $body   Expected body to be sent with the request
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function sendConnectEmail(
        $accept,
        $body
    ) {
        //check that all required arguments are provided
        if (!isset($accept, $body)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/connect/v1/send/email';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'content-type'  => 'application/json; charset=utf-8',
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept
        );

        //json encode body
        $_bodyJson = Request\Body::Json($body);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\GenerateConnectEmailResponseMultiBorrowers');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param integer $customerId   Finicity’s ID of the customer
     * @param string  $reportId     Finicity’s ID of the report (UUID with max length 32 characters)
     * @param string  $accept       Replace 'json' with 'xml' if preferred
     * @param string  $contentType  Replace 'json' with 'xml' if preferred
     * @param string  $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string  $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                              retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getTransactionsReportByCustomer(
        $customerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($customerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/customers/{customerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'customerId'   => $customerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\TransactionsReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param string $consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
     * @param string $reportId     Finicity’s ID of the report
     * @param string $accept       JSON or  XML
     * @param string $contentType  JSON or  XML
     * @param string $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                             retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getTransactionsReportByConsumer(
        $consumerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($consumerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/consumers/{consumerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'consumerId'   => $consumerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\TransactionsReportRecord');
    }

    /**
     * Get the status of your application registration to access FI's with OAuth connections.
     *
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getAppRegistrationStatusV1()
    {

        //prepare query string for API call
        $_queryBuilder = '/aggregation/v1/partners/applications';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json',
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\AppStatusesV1');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param integer $customerId   Finicity’s ID of the customer
     * @param string  $reportId     Finicity’s ID of the report
     * @param string  $accept       Replace 'json' with 'xml' if preferred
     * @param string  $contentType  Replace 'json' with 'xml' if preferred
     * @param string  $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string  $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                              retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStatementReportByCustomer(
        $customerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($customerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/customers/{customerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'customerId'   => $customerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\StatementReportRecord');
    }

    /**
     * Get a report that has been generated by calling one of the Generate Report services.
     *
     * The report's status field will contain inProgress, failure, or success. If the status shows
     * inProgress, the client app should wait 20 seconds and then call again to see if the report is
     * finished.
     *
     * See Permissible Purpose Codes for a list of permissible purposes for retrieving a report.
     *
     * @param string $consumerId   Finicity’s ID of the consumer (UUID with max length 32 characters)
     * @param string $reportId     Finicity’s ID of the report
     * @param string $accept       Replace 'json' with 'xml' if preferred
     * @param string $contentType  Replace 'json' with 'xml' if preferred
     * @param string $onBehalfOf   (optional) The name of the entity you are retrieving the report on behalf of.
     * @param string $purpose      (optional) 2-digit code from Permissible Purpose Codes, specifying the reason for
     *                             retrieving this report.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStatementReportByConsumer(
        $consumerId,
        $reportId,
        $accept,
        $contentType,
        $onBehalfOf = null,
        $purpose = null
    ) {
        //check that all required arguments are provided
        if (!isset($consumerId, $reportId, $accept, $contentType)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/consumers/{consumerId}/reports/{reportId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'consumerId'   => $consumerId,
            'reportId'     => $reportId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'onBehalfOf'   => $onBehalfOf,
            'purpose'      => $purpose,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'          => $accept,
            'Content-Type'    => $contentType
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\Error1ErrorException('Bad Request', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\StatementReportRecord');
    }

    /**
     * Partners would like the capability to see the reports generated for a specific date range as well as
     * the custom fields associated with the report. This will allow partners to determine which branches
     * have generated specific reports to better bill those branches
     *
     * @param string $accept             Replace 'json' with 'xml' if preferred
     * @param string $partnerId          Partner ID From Developer Portal
     * @param string $startDate          The earliest date to be analyzed in this report. This is required.  Note: The
     *                                   range between startDate and endDate must be 31 days or less.
     * @param string $endDate            The latest date to be analyzed in this report. This is required.
     * @param string $viewTestingReports Designate as true to only display testing reports in the response. By default,
     *                                   this is false.
     * @param string $size               (optional) The size of the results returned per page. By default, this is 100
     *                                   results per page and can be no more than 1000 results per page. This is
     *                                   optional.
     * @param string $page               (optional) The page to be viewed. Zero based index. This is optional. Default
     *                                   0.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function invoiceBillingEndpoint(
        $accept,
        $partnerId,
        $startDate,
        $endDate,
        $viewTestingReports,
        $size = null,
        $page = null
    ) {
        //check that all required arguments are provided
        if (!isset($accept, $partnerId, $startDate, $endDate, $viewTestingReports)) {
            throw new \InvalidArgumentException("One or more required arguments were NULL.");
        }


        //prepare query string for API call
        $_queryBuilder = '/decisioning/v1/partners/{partnerId}/billing/reseller';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'partnerId'          => $partnerId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'startDate'          => $startDate,
            'endDate'            => $endDate,
            'viewTestingReports' => $viewTestingReports,
            'size'               => $size,
            'page'               => $page,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => BaseController::USER_AGENT,
            'Finicity-App-Key' => Configuration::$finicityAppKey,
            'Finicity-App-Token' => Configuration::$finicityAppToken,
            'Accept'             => $accept
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'FinicityAPILib\\Models\\InvoiceBillingResponse');
    }
}
